# Функции и структуры

## Зміст

0. [Структура коду](#Структура-кода)
1. [Функції](#функции)
2. [Структури](#Структуры)
3. [Типи користувача](#пользовательские-типы)
4. [Методи структур](#методы-структур)
5. [Інтерфейси](#интерфейсы)
6. [Generics](#generics)

### Структура коду

Код усіх програм і проектів написаних на Go прийнято зберігати і структурувати опереним чином усередині однієї спільної директорії


***Пакет*** - це одиниця організації коду в Go.

Усі файли `.go` з вихідним кодом, що містяться в одній директорії, зобов'язані мати однакове ім'я
пакету `package` `<my pakage name>`.

Go - мова чутлива до регістру ідентифікаторів (імен).

Все що називається з ***В***еликої літери - є доступним ззовні при імпортуванні пакета,
все що названо з ***м***аленкою - приватне і доступне тільки в рамках пакету.

Більш детально описано в офіційному посібнику - https://golang.org/doc/code.html

Наприклад:
```go
package main
import "fmt"
 
func main() {
     
    fmt.Println("Hello Go")
}
```
## Іморт пакетів
Якщо вже є готові пакети з потрібною функціональністю, яку ми хочемо використовувати, то для їх використання ми можемо їх імпортувати в програму за допомогою оператора import. Наприклад, у прикладі вище задіюється функціональність виведення повідомлення на консоль за допомогою функції Println, визначеної в пакеті fmt. Відповідно, щоб використовувати цю функцію, необхідно імпортувати пакет fmt:
```go
import "fmt"
```
Нерідко програми підключають відразу кілька зовнішніх пакетів. У цьому випадку можна послідовно імпортувати кожен пакет:
```go
package main
import "fmt"
import "math"
 
func main() {
     
    fmt.Println(math.Sqrt(16))  // 4
}
```
Або щоб скоротити визначення імпорту пакетів можна укласти всі пакети в дужки:
```go
package main
import (
    "fmt"
    "math"
)
 
func main() {
     
    fmt.Println(math.Sqrt(16))
}
```
# Функції

Фунція - це блок коду, підпрограма, який можна викликати в інших частинах програми. Функція може мати
ідентифікатор, прийняті та повертаються значення.

За допомогою функцій можна часто викликати її блок операторів як єдине ціле в інших частинах програми.

```go
func functionName(argumentName argumentType)(returnableName returnableType){
// function body
}
```

Функція може приймати від 0 до N у агрументів і при цьому повертати від 0 до M значень.

```go
func functionName(argA typeA, argC1, argC2  typeC, arr ...typeD)(retA typeE){
// function body
}
```

Функція визначається за допомогою ключового слова func, після якого відбувається ім'я функції. Потім у дужках іде список
параметрів. Після списку параметрів визначаються типи значень, що повертаються з функції (якщо функція повертає
значення). І далі у фігурних дужках йдуть ті оператори, з яких складається функція.

Назва функції разом із типами її параметрів і типами значень, що повертаються, ще називають сигнатурою.

За замовчуванням кожна програма на мові Go повинна містити щонайменше одну функцію - функцію main, яка є
вхідною точкою у додаток:

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello Go")
}
```

### Closure. Замикання (Анонімні функції)

Анонімні функції - це функції, яким не призначено ім'я. Вони відрізняються від звичайних функцій також тим, що можуть
визначатися всередині інших функцій і можуть мати доступ до контексту виконання.

Анонімні функції дозволяють визначити певну дію безпосередньо там, де воно застосовується. Наприклад, нам
треба виконати складання двох чисел, але більше ніде ця дія в програмі не потрібна:

```go
package main

import "fmt"

func main() {

	f := func(x, y int) int { return x + y }
	fmt.Println(f(3, 4)) // 7
	fmt.Println(f(6, 7)) // 13
}
```

Також функції можуть приймати замикання як вхідні параметри або повертати замикання як результат виконання:

```go
package main

import (
	"fmt"
	"time"
)

type Ny func() func(string) string

func main() {
	var myTime Ny
	myTime = sss()
	mt2 := myTime
	mt2()
	f := func() {
		str := myTime()("Johnny")
		println(str)
	}

	defer func() {
		println("defer executed")
	}()

	f()
}

func sss() func() func(string) string {
	start := time.Now()
	return func() func(string) string {
		fmt.Printf("Time from start %v", time.Since(start))
		return getTime
	}
}

func getTimer() func() {
	start := time.Now()
	return func() {
		fmt.Printf("Time from start %v\n", time.Since(start))
	}
}

func getTime(name string) string {
	return fmt.Sprintf("Hi, %s! %v", name, time.Now().String())
}

```

## Оператор defer

Оператор defer дозволяє виконати певну функцію в кінці програми, при цьому не важливо де в реальності
викликається ця функція. Наприклад:

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}

func Readfile(f string) ([]byte, error) {
	file, err := os.OpenFile(f, 0, 0666)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	return nil, nil
}
```

У функції `Readfile` оператор служить для дуже корисної функції: не забути закрити файловий дескриптор після
різноманітних операцій із вмістом файлу.
У цьому прикладі `defer` функції `main` несе декоративний характер, але демонструє послідовність виконання
визначених за допомогою `defer` дій після завершення основного коду функції. А саме: їх послідовність
виконання назад порядку їх визначення. Таку послідовність можна описати як "закриття стеку викликів".

## panic & recover

Оператор panic дозволяє згенерувати помилку та вийти з програми:

```go
package main

import "fmt"

func main() {
	fmt.Println(divide(15, 5))
	fmt.Println(divide(4, 0))
	fmt.Println("Program has been finished")
}
func divide(x, y float64) float64 {
	if y == 0 {
		panic("Division by zero!")
	}
	return x / y
}
```

Оператору `panic` ми можемо передати будь-яке повідомлення, яке виводитиметься на консоль. Наприклад, у цьому випадку
функції `divide`, якщо другий параметр дорівнює 0, то здійснюється виклик `panic("Division by zero!")`.

У функції `main` у виклику `fmt.Println(divide(4, 0))` буде виконуватися оператор `panic`, оскільки другий параметр
функції `divide` дорівнює 0. І в цьому випадку всі наступні операції, які йдуть після цього виклику, наприклад, у цьому
випадку це виклик `fmt.Println("Program has been finished")`, не будуть виконуватися. У цьому випадку ми отримаємо
наступне виведення тексту в консоль:

```text
3
panic: Division by zero!
```

І наприкінці виведення йтиме діагностична інформація про те, де виникла помилка.

### Робота з recovery

У разі ситуації `panic` програма завершується. Завершення роботи реального додатку на помилці - це не найкраще, що
можливо. Потрібен якийсь механізм відновлення після помилки. У ситуації `panic` хотілося б мати код відновлення, що
допомагає уникнути небажаного завершення програми.

Функція `defer` завжди виконується при поверненні функції, причому виконуваної функції `ситуація` panic може виникати, а
може і не виникати. Ми можемо вказати всередині функції `defer` сценарій відновлення.

### Виявлення ситуації panic

Ми повинні перевірити всередині функції `defer`, чи виникала ситуація `panic` у виконанні функції. Для цього виконуємо
функцію відновлення `recover`. При виконанні `recover` всередині `функції` defer ми отримуємо код повідомлення про
помилку, що збігається зі значенням параметра, що передається до функції `panic`. Як результат від функції `recover`
повертається рядок, переданий у функцію panic. Це не дає завершитися програмі, що виконується, і повертає контроль над
нею. Згодом контроль передається зухвалої функції, яка продовжує виконання у звичайному режимі. Спробуємо все це на
прикладі:

```go
package main

import "fmt"

func recoveryFunction() {
	if recoveryMessage := recover(); recoveryMessage != nil {
		fmt.Println(recoveryMessage)
	}
	fmt.Println("This is recovery function...")
}

func executePanic() {
	defer recoveryFunction()
	panic("This is Panic Situation")
	fmt.Println("The function executes Completely")
}

func main() {
	executePanic()
	fmt.Println("Main block is executed completely...")
}
```

У цьому коді всередині функції `defer` ми викликаємо функцію відновлення `recover`, яка повертає повідомлення `panic`,
передане аргументом `panic` функції.

Так як ми використовуємо `recover`, функція не завершуватиметься негайно: контроль над функцією буде повернено до
виклику функції `main`, а виконання продовжиться в нормальному режимі. У такий спосіб відбудеться відновлення після
ситуації `panic`.

Результат виконання буде таким:

```text
This is Panic Situation
This is recovery function...
Main block is executed completely...

Process finished with the exit code 0
```

Тут бачимо, що функція не завершується. Вона повертає виконання в функцію main, що викликає, і далі виконання проходить
у звичайному режимі.

**Висновок**

`Golang` досить сильно відрізняється від інших мов програмування щодо обробки помилок.

# Структуры

Структури представляють тип даних, що визначається розробником і необхідне представлення будь-яких об'єктів. Структури
містять набір полів, які представляють різні атрибути об'єкта. Для визначення структури застосовуються ключові слова
type та struct:

```text
type имя_структуры struct{
    поля_структуры
}
```

Кожне поле має назву та тип даних, як змінна. Наприклад, визначимо структуру, яка представляє людину:

```go
package internal

type person struct{
    name string
    age int
}

```

Структура називається `person`. Вона має два поля: name (ім'я людини, представляє тип string) та age (вік людини,
представляє тип int).

## Створення та ініціалізація структури

Структура представляє новий тип даних, і ми можемо визначити змінну цього типу:

``` go
var tom person
```

За допомогою ініціалізації можна передати структурі початкові значення:

```go
package person

type person struct {
	name string
	age  int
}

var tom person = person{"Tom", 23}
```

Ініціалізатор представляє набір значень у фігурних дужках. Причому ці значення передаються полям структури у порядку, у
якому поля визначено у структурі. Наприклад, у разі рядок " Tom " передається першому полю - name, а друге значення - 23
передається другому полю - age.

Також ми можемо явно вказати які значення передаються властивостям:

```go
package persons

type person struct {
	name string
	age  int
}

var alice person = person{age: 23, name: "Alice"}
```

Також можна використовувати скорочені способи ініціалізації змінної структури:

```go
var tom = person {name: "Tom", age: 24}
bob := person {name: "Bob", age: 31}
```
### Вкладені структури
Поля одних структур можуть становити інші структури. Наприклад:
```go
package main
import "fmt"
 
type contact struct{
    email string
    phone string
}
 
type person struct{
    name string
    age int
    contactInfo contact
}
 
func main() {
     
    var tom = person {
        name: "Tom", 
        age: 24,
        contactInfo: contact{
            email: "tom@gmail.com",
            phone: "+1234567899",
        },
    }
    tom.contactInfo.email = "supertom@gmail.com"
     
    fmt.Println(tom.contactInfo.email)      // supertom@gmail.com
    fmt.Println(tom.contactInfo.phone)      // +1234567899
}
```
У даному випадку структура людини має поле contactInfo, яке представляє іншу структуру contact.

Ви можете скоротити визначення поля таким чином:
```go
package main
import "fmt"
 
type contact struct{
    email string
    phone string
}
 
type person struct{
    name string
    age int
    contact
}
 
func main() {
     
    var tom = person {
        name: "Tom", 
        age: 24,
        contact: contact{
            email: "tom@gmail.com",
            phone: "+1234567899",
        },
    }
    tom.email = "supertom@gmail.com"
     
    fmt.Println(tom.email)      // supertom@gmail.com
    fmt.Println(tom.phone)      // +1234567899
}
```
Поле contact у структурі person фактичні еквівалентно властивості contact contact, тобто властивість називається contact і представляє тип contact. Це дозволяє скоротити шлях до полів вкладеної структури. Наприклад, можемо написати tom.email, а не tom.contact.email. Хоча можна використати і другий варіант.
# Вказівники
## Що таке вказівники (pointer)
Pointer є об'єктами, значенням яких є адреси інших об'єктів (наприклад, змінних).

Pointer визначається як звичайна змінна, лише перед типом даних ставиться символ зірочки`*`. Наприклад, визначення pointer на об'єкт типу `int`:
```go
var p *int
```
Цьому pointer можна присвоїти адресу змінної типу `int`. Для отримання адреси використовується операція `&`, після якої вказується ім'я змінної `(&x)`.
```go
package main
 
import "fmt"
 
func main() {
     
    var x int = 4       // Визначаємо змінну
    var p *int          // Визначаємо pointer на змінну
    p = &x              // pointer отримує адресу змінної
    fmt.Println(p)  // значення самого pointer - адреса змінної x
}
```
Тут pointer p зберігає адресу змінної `x`. Що важливо, змінна `x` має тип `int` і pointer `p` вказує саме на об'єкт типу `int`. Тобто має бути відповідність на кшталт. І якщо ми спробуємо вивести адресу змінної на консоль, то побачимо, що вона становить шістнадцяткове значення:
```
0xc0420120a0
```
У кожному окремому випадку адреса може відрізнятися, але, наприклад, в моєму випадку машинна адреса змінної `x` - `0xc0420120a0`. Тобто в пам'яті комп'ютера є адреса `0xc0420120a0`, за якою розміщується змінна `x`.

За адресою, яку зберігає pointer, ми отримаємо значення змінної x. Для цього застосовується операція * або операція розіменування. Результатом цієї операції є значення змінної, яку вказує pointer. Застосуємо цю операцію та отримаємо значення змінної `x`:
```go
package main
 
import "fmt"
 
func main() {
     
     var x int = 4
     var p *int = &x // pointer отримує адресу змінної
     fmt.Println("Address:", p) // значення pointerа - адреса змінної x
     fmt.Println("Value:", *p) // значення змінної x
}
```

Консольне виведення даної програми:
```
Address: 0xc0420c058
Value: 4
```
І також використовуючи pointer (, ми можемо змінювати значення за адресою, яка зберігається в pointerу:

```go
var x int = 4
var p *int = &x
*p = 25
fmt.Println(x)      // 25
```
## Порожній pointer
Якщо вказівнику не присвоєно адресу будь-якого об'єкта, такий вказівник за замовчуванням має значення nil (по суті відсутність значення). Якщо ми спробуємо отримати значення за таким порожнім pointerом, то зіткнемося з помилкою:
```go
var pf *float64
fmt.Println("Value:", *pf) // ! помилка, pointer не вказує на будь-який об'єкт
```
Тому при роботі з pointerами іноді буває доцільно перевіряти значення nil:
```go
var pf *float64
if pf != nil{
    fmt.Println("Value:", *pf)
}
```
## Функція new
Змінна представляє іменований об'єкт у пам'яті. Мова Go також дозволяє створювати безіменні об'єкти – вони також розміщуються у пам'яті, але не мають імені як змінні. Для цього використовується функція new(type). У цю функцію передається тип, об'єкт якого потрібно створити. Функція повертає pointer на створений об'єкт:
```go
package main
 
import "fmt"
 
func main() {
     
     p := new(int)
     fmt.Println("Value:", *p) 	// Value: 0 - значення за замовчуванням
     * p = 8 					// змінюємо значення
     fmt.Println("Value:", *p) 	// Value: 8
}
```

У разі pointer p матиме тип *int, оскільки він свідчить про об'єкт типу int. Об'єкт, що створюється, має значення за замовчуванням (для типу int це число 0).

Об'єкт, створений за допомогою функції new, нічим не відрізняється від звичайної змінної. Єдине, щоб звернутися до цього об'єкта - отримати або змінити його адресу, необхідно використовувати pointer.

# Повернемося до структур
### Зберігання посилання на структуру того ж типу
При цьому треба враховувати, що структура не може мати поле, яке представляє тип цієї структури. Наприклад:
```go
type node struct{
    value int
    next node //Помилка!
}
```
Подібне визначення буде неправильним. Натомість поле має представляти pointer на структуру:
```go
package main
import "fmt"
 
type node struct{
    value int
    next *node
}
 
// рекурсивный вывод списка
func printNodeValue(n *node){
     
    fmt.Println(n.value)
    if n.next != nil{
        printNodeValue(n.next)
    }
}
func main() {
     
    first := node{value: 4}
    second := node{value: 5}
    third := node{value: 6}
     
    first.next = &second
    second.next = &third
     
    var current *node = &first
    for current != nil{
        fmt.Println(current.value)
        current = current.next
    }
}
```
Тут визначено структуру node, яка представляє типовий вузол однозв'язкового списку. Вона зберігає значення в полі value та посилання на наступний вузол через pointer next.

У функції main створюються три пов'язані структури, і з допомогою циклу for і допоміжного pointerа current виводяться їх значення.

Консольне виведення даної програми:

```
4
5
6
```

# Типи користувача

### Оголошення типів
Оператор типу дозволяє визначати іменований тип. Саме ванний тип ґрунтується на вже існуючому типі. Наприклад:

```go
type mile int
```
В даному випадку визначається тип mile, який ґрунтується на типі int. По суті mile представляє тип int і з ним проводитиметься як і з типом int. Однак у той самий час фактично це новий тип.

Ми можемо визначати змінні цього типу, працювати з ними як з об'єктами базового типу int:
```go
package main
import "fmt"
 
type mile int
 
func main() {
     
    var distance mile = 5
    fmt.Println(distance)
    distance += 5
    fmt.Println(distance)
}
```
Але може виникнути питання, а навіщо це потрібно, навіщо створювати новий тип, якщо він все одно веде себе як тип int? Розглянемо таку ситуацію:
```go
package main
import "fmt"
 
type mile int
type kilometer int
 
func distanceToEnemy (distance mile){
     
    fmt.Println("відстань для супротивника:")
    fmt.Println(distance, "миль")
}
 
func main() {
     
    var distance mile = 5
    distanceToEnemy(distance)
    var distance2 kilometer = 5
    // distanceToEnemy(distance2)   // ! ошибка
}
```
Тут визначено два іменованих типи: mile і kilometer, які по суті представляють тип int і призначені для вираження відстані в милях та кілометрах відповідно. І також визначено функцію distanceToEnemy(), яка відображає відстань в милях до умовного супротивника. Як параметр приймає значення mile - саме значення типу mile, а чи не типу int. 

Це дозволить нам зменшити можливість передачі некоректних даних. Тобто дані, що передаються, повинні бути явно визначені в програмі як значення типу mile, а не типу int або типу kilometer. Таким чином, за допомогою саме ванних типів ми надаємо типу деякий додатковий зміст.

Розглянемо ще один приклад:

```go
package main
import "fmt"
 
type library []string
 
func printBooks(lib library){
 
    for _, value := range lib{
     
        fmt.Println(value)
    }
}
 
func main() {
     
    var myLibrary library = library{"Book1", "Book2", "Book3"}
    printBooks(myLibrary)
}
```
Тут визначено іменований тип library, який по суті є зрізом з рядків. Даний тип представлятиме своєрідну бібліотеку, яка включає книги у вигляді їх рядкових назв. За допомогою функції printBooks можна вивести всі книги цієї бібліотеки. При цьому функція printBooks працює саме з типом library, а не з будь-яким зрізом рядків.
# Методи структур та типів
Метод представляє функцію, що з певним типом. Методи визначаються як і звичайні функції за винятком, що у визначенні методу також необхідно вказати одержувача чи receiver. Одержувач - це параметр типу, до якого прикріплюється метод:
```
func (ім'я_параметра тип_одержувача) ім'я_методу (параметри) (типи_результатів){
     тіло_метода
}
```
Допустимо, у нас буде визначений іменований тип, що представляє зріз з рядків:
```go
type library []string
```

Для виведення всіх елементів із зрізу ми можемо визначити такий метод:
```go
package internal
import "strings"

type library []string

// String Об'єднання у рядок
func (l library) String() string{
	return strings.Join(l,"; ")
}

// Print Друк library
func (l library) Print() {
	println(l.String()) 
}
```
Та частина, яка розташована між ключовим словом func та ім'ям методу та представляє визначення одержувача, для якого буде визначено цей метод:` (l library)`. Використовуючи параметр одержувача (у разі `l`), ми можемо звертатися до одержувача. Наприклад, у разі одержувач представляє зріз - набір об'єктів. За допомогою циклу for можна пройтися цим зрізом і вивести всі його елементи на консоль.

Оскільки `Print` представляє саме метод, який визначений для типу library, а не звичайну функцію, ми можемо викликати цей метод у будь-якого об'єкта типу library:
```go
var lib library = library{ "Book1", "Book2", "Book3" }
lib.Print() //  Book1; Book2; Book3
```
## Методи структур
Подібним чином ми можемо визначати методи і для структур:
```go
package main
 
import "fmt"
 
type person struct{
    name string
    age int
}
func (p person) print(){
    fmt.Println("Ім'я:", p.name)
    fmt.Println("Вік:", p.age)
}
 
func (p person) eat(meal string){
    fmt.Println(p.name, "їсть", meal)
}
 
func main() {
     
    var tom = person { name: "Tom", age: 24 }
    tom.print()
    tom.eat("борщ із капустою, але не червоний")
}
```
Консольне виведення даної програми:
```
Ім'я: Tom
Вік: 24
Tom їсть борщ з капустою, але не червоний
```

# Интерфейсы

//TODO